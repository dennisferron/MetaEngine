
Node
	Domain
		ActiveObjects
			subdomains (by string keys)
				list of e.g. NodeAttributes
				
		ActiveInteractions
			generated by addObject
	
	static list possibleInteractions
		added to by registerInteraction
	
Interaction
	static subdomains list
	referent
		subdomains (by string key)
			Referent
				Trigger
					Slot name
					Proto name


Individual Interactions
	setReferent(mapSubdomains) sets a slot named referent to a dictionary of string to Referent

	mapSubdomains is just equivalent to subdomains.ToDictionary(a => a, a => new Referent)

	subdomains is just a list which varies per kind of Interaction (node, component, or link).

	NodeInteraction "component", "node"
	LinkInteraction "fromNode", "toNode", "style", "link", "component"
	ComponentInteraction "component"

	(BTW the "node" subdomains of each end of a Link get turned into "fromNode" and "toNode" by mergeSubdomains)

	Additionally an interaction can access the Node, Link, or Component resp. by referencing the "site" slot
	which is a member of the base Interaction proto

Interaction
    hasOneTrigger := method(subdomain, newObj,
	Check if the referents map has key "subdomain" 
	Then ask that Referent object if it in turn hasOneTrigger of newObj

    isFullyTriggeredBy := method(activeObjects,
	Join referents and activeObjects on subdomain keys
	Check that all Referents are isFullyTriggeredBy(activeObjects[subdomain])

    with := method(activeObjects,
	foreach Referent in referents dictionary, Referent fillSlots(self /*the new interaction instance*/, activeObjects[subdomain]
	invoke the enter method on the new interaction instance and return it (equivalent to RAII)

Domain
	The Domain manages a set of activeObjects and a set of activeInteractions for one site
	Graph, Link, and Node each have a Domain member to manage their activeObjects and activeInteractions

	addObject(char const* subdomain, void* newObj)
		Adds newObj to the active objects under the given subdomain (e.g. 
		Then adds (zero to many) new interactions to activeInteractions
		foreach possibleInteractions of the domain's site
			if the interaction hasOneTrigger with subdomain of this obj
				then check if now the interaction isFullyTriggeredBy all activeObjects
					if so then create an instance of the Interaction with site and activeObjects

Referent
    Trigger := Object clone do(
        findProto is the name of the Proto 
        withSlot is the slot to be created
        triggeredBy(r) => r hasProto(findProto)
    )

    hasOneTrigger := method(rep /* aka newObj */,
	Check the set of triggers to see if any are triggered by that obj

    isFullyTriggeredBy := method(objs /* aka activeObjects[subdomain] */,
	Check that all triggers are triggeredBy at least one obj

    fillSlots := method(target /* the interaction */, objs /* activeObjects[subdomain] */,
	foreach trigger find it in the subdomain objs and set the slot on the target


Site

	Domain has a site, when the interaction is created it calls setSite(site) on the interaction
	Graph|Link|Node has a Domain, calls setSite(self) on the domain.  So site is either Graph, Link, or Node
		TODO: Should we just make Graph|Link|Node be instances of Domain?
	site is used in BulletMouseDrag LinkInteraction to remove the link constraint attribute on leave (but is it ever added?)
	site is used in IrrlichtCamera NodeAttribute to add irrComp camera on enter (but does not remove it on leave!)
		The trigger for IrrlichtCamera is irrlicht component and avatar camera, so basically it translates avatar camera into specific implementation
		However it also nabs the Time component so that time beforeGraphics will update the irrlicht camera. This could have been a separate interaction.
		There is no implementation for leave.
	site is used in Domain to get possibleInteractions to activate in addObject
	
		


